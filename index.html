<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>VIP Academy – Backend</title>

		<meta name="description" content="Slides for the presentation">
		<meta name="author" content="asdf">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">
		
		<link rel="stylesheet" href="css/custom.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section>
					<h1>VIP Academy</h1>
					<h3>Backend</h3>
				</section>
				
				
				<section>
					<h3>AGENDA Eventu - Dzien 1</h3>
					<ul>
						<li>                          10.30 - 12.00 rozgrzewka
						<li>                          12.00 - 13.30 pierwszy wykład
						<li>                          13:30 - 14:15 obiad
						<li><span class="agendaEvent">14:15 - 16:30 praca w streamach 1</span>
						<li>                          16:30 - 17:00 przerwa 
						<li><span class="agendaEvent">17:00 - 19.00 praca w streamach 2</span>
						<li>                          19:00 - 20:00 kolacja
						<li><span class="agendaEvent">20:00 - 22:30 praca w streamach 3</span>				

					</ul>
				</section>
				
				<section>
					<h3>AGENDA Eventu - Dzien 2</h3>
					<ul>
						<li>                          6:00 - 6:40 rozgrzewka
						<li>                          7:00 - 7:30 sniadanie
						<li><span class="agendaEvent">7:30 - 12:00 praca w streamach</span>
						<li>                          12:00 - 13:30 obiad
						<li>                          13:30 - 16:00 przerwa - 
						<li>                          16:00 - 18:00 drugi wykład 
						<li><span class="agendaEvent">18:00 - 20:30 praca w streamach</span>
						<li>                          20:30 - kolacja grilowa
					</ul>
				</section>
				
				<section>
					<h3>AGENDA Eventu - Dzien 3</h3>
					<ul>
						<li>                          6:00 - 6:40 rozgrzewka
						<li>                          7:00 - 7:30 sniadanie
						<li><span class="agendaEvent">7:30 - 12:00 Praca w streamach</span>
						<li>                          12:00 -13:00 obiad
						<li>                          13:00 -15:00 Podsumowanie i zakończenie
					</ul>
				</section>

				<section>
					<h2>Agenda Właściwa</h2>
					<ol>
						<li><a href="#/2">Spring Framework</a></li>
						<li><a href="#/2">Maven</a></li>
						<li><a href="#/3">Spring Boot</a></li>
						<li><a href="#/4">Architektura wielowarstwowa</a></li>
						<li><a href="#/5">RESTful Services</a></li>
						<li><a href="#/6">Relacyjne bazy danych a świat obiektowy</a></li>
						<li><a href="#/7">Dostęp do danych za pomocą JDBC</a></li>
						<li><a href="#/8">Odwzorowanie obiektowo-relacyjne</a></li>
						<li><a href="#/9">DAO</a></li>
						<li><a href="#/10">Transakcje</a></li>
						<li><a href="#/11">Testy</a></li>
					</ol>
				</section>
				
				<!--     Spring Framework     -->
				
				<section>
					<h2>Spring Framework</h2>
					<ul>
						<li>Powstał w 2003 roku</li>						
						<li>Szkielet tworzenia aplikacji dla języka Java</li>
						<li>Alternatywa dla programowania w EJB</li>
						<li>Oferuje dużą swobodę wytwarzania oprogramowania</li>
						<li>Bardzo dobra dokumentacja</li>
						<li>Gotowa implementacja wielu zagadnień</li>
						<li>Ogromne wsparcie dla Java EE</li>
						<li>Propaguje poprawny styl programowania</li>
						<li>Jest dostępny na zasadach open source</li>
					</ul>
				</section>	
				
				<section>
					<h3>Spring Framework - moduły</h3>
					<ul>
						<li>Składa się z kilku niezależnych od siebie modułów</li>
						<li>Moduły można ze sobą łączyć w celu uzyskania większej funkcjonalności</li>
					</ul>
					<img src="images/spring_modules.png" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
					<h3>Spring Framework – podstawowy kontener</h3>
					<ul>
						<li>Core</li>
							<ul> <li>podstawowa część frameworka, zawiera IoC i wstrzykiwanie zależności</li> </ul>
						<li>Beans</li>
							<ul> 	
								<li>eliminuje potrzebę programowego tworzenia singletonów</li>
								<li>oddziela zależność pomiędzy konfiguracją, specyfikacją a logiką programu</li> 
							</ul>
					</ul>
				</section>	

				<section>
					<h3>Spring Framework – podstawowy kontener</h3>
					<ul>							
						<li>Context</li>
							<ul> 	
								<li>umożliwia dostęp do obiektów zarządzanych przez framework</li>
								<li>pozwala na wydzielenie konfiguracji do plików *.properties</li>
								<li>udostępnia interface ApplicationContext</li> 
							</ul>
						<li>EL - Spring Expression Language</li>
					</ul>
					<pre><code class="Java" data-trim contenteditable>
@Value("#{applicationProperties['jakas.zmienna.z.pliku.properties']}")
private String zmienna;
					</code></pre>
				</section>
				
				<section>
					<h3>Inversion of Control, Dependency Injection</h3>
					<ul>
						<li>Paradygmat programowania, wzorzec projektowy, wzorzec architektoniczny.
						<li>Zastosowanie 
							<ul>
								<li>w pojedynczych komponentach,
								<li>w architekturze całego systemu (Spring Framework)
							</ul>
						<li>W klasycznym podejściu obiekty są budowane statycznie, brak wpływu na ich postać.
						<li>Odwracamy kontrolę – budowaniem obiektów zajmuje się framework
					</ul>
				</section>
				
				
				<section>
					<h3>Inversion of Control, Dependency Injection</h3>
					<b>Wstrzykiwanie zależności</b> – dla danego obiektu definiujemy, z jakich innych komponentów będzie korzystał, ale nie musimy się martwić o tworzenie instancji tych obiektów – zrobi to za nas framework, wykorzystywane w Springu.
					
										<pre><code class="Java" data-trim contenteditable>
@Service
public class CustomerServiceImpl {

	private final CustomerMapper customerMapper;
	private final CustomerDao customerDao;
	
	@Autowired
	public CustomerServiceImpl (CustomerMapper mapper, CustomerDao dao) {
		this.customerMapper = mapper;
		this.customerDao = dao;
	}
					</code></pre>
				</section>
				
				<section>
				<h3>Jak zacząć ze springiem?</h3>
				
				<ol> 	
					<li> Podłączyć jary sciągnięte z internetu
					<li> <p class="fragment">W internecie poszukać dependency do POMa i podłączyć     </p>
					<li> <p class="fragment">Sciągnąć kompletny STS (Spring Tool Suite)               </p>
					<li> <p class="fragment">start.spring.io                                          </p>
				</ol>
				</section>
				
				<section>
				<h3>Spring framework - podstawy</h3>
				<pre><code class="Java" data-trim contenteditable>
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication
public class BooksServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(BooksServerApplication.class, args);
	}
}
					</code></pre>
				</section>
				
				<section>
				<h3>Spring framework - adnotacje</h3>
					<ul>
						<li><b>@Component</b> - podstawowa adnotacja, określa że klasa jest zarządzana przez Spring
						<li><b>@Service</b> - określa klasę zawierającą logikę biznesową
						<li><b>@Repository</b> - klasy DAO (Data Access Object), bezpośrednia komunikacja z DB
					</ul>
					
						<p class="fragment">Wszystkie działają i robią to samo</p>
							<p class="fragment">Wyjątkiem jest @Repository, która dodatkowo konwertuje wyjątki dostawców bazy danych</p>
						<p class="fragment">Adnotacje pozwalają oddzielić od siebie różne warstwy aplikacji</p>
						<p class="fragment">Ułatwiają czytanie i analizowanie kodu</p>
				</section>
				
				<section>
				<h3>Spring framework - adnotacje</h3>
					<ul>
						<li><b>@Controller</b> - przetwarza żądania HTTP
						<li><b>@Scope</b> - umożliwia zmianę domyślnego czasu życia bean’a
						<li><b>@PostConstruct</b> - umożliwia wywołanie części kodu zaraz po utworzeniu obiektu
						<li><b>@RequestMapping</b> - używana w kontrolerze, mapuje adres URL na metodę
					</ul>
				</section>
				
				<section>
				<h3>Adnotacje - przykład</h3>
				<pre><code class="Java" data-trim contenteditable>
@RequestMapping("/services")
@RestController
public class BooksRestService {

    private final BookService bookService;

    @Autowired
    public BooksRestService(BookService bookService) {
        this.bookService = bookService;
    }

    @RequestMapping(path = "/books", method = RequestMethod.GET)
    public List&lt;BookTo&gt; findBooks(BookSearchCriteria bookSearchCriteria) {
        return bookService.findBooks(bookSearchCriteria);
    }
}
					</code></pre>
				</section>
				
				
				<!--     Maven     -->
				<section>
				<h3>Maven</h3>
                    <ul>
                      <li>Cel - Automatyzacja i standaryzacja procesu budowania</li>
                      <li>Umożliwia opis procesu budowania oprogramowania</li>
                      <li>Pozwala na zdefiniowanie zależności oraz zarządzanie nim</li>
                      <li>Centralne repozytorium artefaktów - search.maven.org</li>
                      <li>Lokalne repozytorium - zdef</li>
                    </ul>
				</section>
                <section>
                  <h3>Struktura projektu - convention over configuration</h3>
                  <img src="images/mvn.PNG" style="background:none; border:none; box-shadow:none;">
                </section>
              
                <section>
                  <h3>Konfiguracja projektu - POM (Project Object Model)</h3>
                  <img src="images/pom.png" style="background:none; border:none; box-shadow:none;">
                </section>
              
                <section>
                  <h3>Maven build lifecycle</h3>
                  <ul>
                      <li>Zadania wykonywane kaskadowo - wykonanie konkretnego kroku powoduje również wykonanie wszystkich poprzedzających</li>
                      <li>mvn compile</li>
                    <li>Deweloper najczęściej używa <b>mvn clean install</b></li>
                    <li>Poszczególne pluginy korzystają ze zdefiniownaych faz w celu wykonania własnej akcji, np. <b>mvn surefire:test</b></li>
                  </ul>
                  <img src="images/mvn_build.png" style="background:none; border:none; box-shadow:none;">
                </section>
				
			    <section>
                  <h3>Zarządzanie zależnościami - dependency management</h3>
                  <ul>
                      <li>Każda biblioteka posiada unikalny identyfikator - groupId, artifactId, version</li>
                      <li>Plik pom.xml zawiera sekcję dependencyManagement z listą zależności</li>
                      <li>Zależności są aktualizowane w procesie budowania</li>
                      <li>Centralne repozytorium artefaktów - search.maven.org</li>
                      <li>Lokalne repozytorium - lokalizacja definiowana dla użytkownika</li>
                    </ul>
                  <img src="images/mvn_dependencies.png" style="background:none; border:none; box-shadow:none;">
                </section>  	
              
				<!--     Spring Boot     -->								
				<section>
				<h3>Dlaczego Spring Boot?</h3>                    
                  <img src="images/spring_summary.png" style="background:none; border:none; box-shadow:none;" >
                  <h5>+ Konfiguracja = Aplikacja startowa</h5>
				</section>				
                <section>
				<h3>Spring Boot</h3>                    
                  <ul>
                      <li>Convention over configuration</li>                      
                      <li>Przy zerowej konfiguracji działająca aplikacja</li>
                      <li>Prekonfiguracja możliwa dzięki adnotacjom @Conditional...</li>
                      <li>Generator projektu - start.spring.io</li>
                  </ul>
				</section>				
								
				<section>
				<h3>Spring boot / Startery</h3>
                  <ul>
                      <li>Zestawy zależności udostępniające prekonfigurowane funkcje Springa</li>                      
                      <li>Np. dla aplikacji bazodanowej: <pre><code>spring-boot-starter-data-jpa</code></pre></li>
                      <li>Lista starterów -> <a href='https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters'>spring-boot-starters</a></li>                    
                      <li>Jak użyc? -> pom.xml</li>                      
    <pre><code class="Xml">    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;</code></pre>
                  </ul>
				</section>				
								
				<section>
				<h3>Deployment aplikacji Spring Boot</h3>
                  <ul>
                      <li>Embedded Server</li>                      
                    <ol><li>Przy użyciu np. startera <pre><code class="Xml">spring-boot-starter-web</code></pre>
                      jar wynikowy (mvn clean install) zawiera jary Tomcata</li>
                    <li>Start klasy aplikacji uruchamia wbudowanego Tomcata (możliwe jest również użycie Jetty)</li>
                    </ol>  
                      <li>Klasyczny serwer J2EE lub zewnętrzny Tomcat</li>
                      Zmiana pliku docelowego na war, niewielkie zmiany w pom.xml
                  </ul>
				</section>
				
				<!--     ZADANIE DO WYKONANIA 
					a.	Wygenerować projekt na stronie start.spring.io z zależnością na „Web”
					b.	Rozpakować plik Zip do workspace w IDE
					c.	Otworzyć IDE
					d.	File->Import->Existing Maven Projects, wybrać lokalizację rozpakowanego projektu
					e.	Dodać klasę z kontrolerem REST, metodą zwracającą String „Hello World” oraz mappingiem URL
					f.	Skonfigurować port dla serwera -> application.properties
					g.	Uruchomić klasę DemoApplication
					h.	Przejść na stronę localhost:<port>/<mapping url> i sprawdzić działanie
				-->
				<section>
					<h4>ZADANIE: HelloWorld @ SpringBoot</h4>
					<small>k
					<ol>
						<li>Wygenerować projekt na stronie start.spring.io z zależnością na „Web”
						<li>Rozpakować plik Zip do workspace w IDE
						<li>Otworzyć IDE
						<li>File->Import->Existing Maven Projects, wybrać lokalizację rozpakowanego projektu
						<li>Dodać klasę z kontrolerem REST, metodą zwracającą String „Hello World” oraz mappingiem URL
						<li>Skonfigurować port dla serwera -> application.properties
						<li>Uruchomić klasę DemoApplication
						<li>Przejść na stronę localhost:&lt;port&gt;/&lt;mapping url&gt; i sprawdzić działanie
					</ol>
					</small>
				</section>
				
				<!--     Architektura wielowarstwowa     -->
				<section>
					<h3>Architektura wielowarstwowa</h3>
					Efekt zastosowania SRP (Single Responsibility Principle)
					<table>
						<thead>
							<tr>
								<th>Rola</th>
								<th>Nazwa Warstwy</th>
								<th>Odpowiedzialność</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Komunikacja FrontEnd</td>
								<td>REST Service</td>
								<td>tłumaczenie requestów</td>
							</tr>
							<tr>
								<td>Use Case</td>
								<td>Service</td>
								<td>logika biznesowa</td>
							</tr>
							<tr>
								<td>Baza danych</td>
								<td>Repository / DAO</td>
								<td>persystencja</td>
							</tr>
						</tbody>
					</table>
				</section>
				
				<section>
					<h3>Architektura wielowarstwowa</h3>
					Czym jest Repository:
					<p><i>A Repository represents all objects of a certain type as a conceptual set. It acts like a collection, except with more elaborate querying capability.</i>[DDD]</p>
				</section>
				
				
				<!--     RESTful Services     -->
				<section>
					<h3>RESTful Services</h3>
					<p><b>REST</b> - REpresentation State Transfer. Roy Fielding 2000.</p>
					<p>REST to nie jest architektura, tylko pewien zespół ograniczeń, który jeśli jest zastosowany do architektury to nadaje konkretne role danym, komponentom, hyperlinkom, ...</p>
				</section>
				<section>
					<h3>RESTful Services</h3>
					Wymagania stawiane przez definicję REST:
					<ol>
						<li>system klient - server
						<li>system bezstanowy
						<li>system keszujący*
						<li>system jednolicie dostępny*
						<li>system wielowarstwowy
					</ol>
					<p>RESTful - spełniający wszystkie punkty powyższych założeń.</p>
				</section>
				<section>
					W świecie aplikacji internetowych definicja przekłada się na następujących kilka elementów:
					<ul>
						<li>Dane przesyłane między klientem a serwerem są pewną reprezentacją bytów biznesowych: XML, JSON
						<li>Dane przemieszczają się do konkretnego adresata URI (Uniform Resource Identifier)
						<li>Dane dodatkowo posiadają pewien kwalifikator akcji, mający odpowiednik w świecie protokołu HTTP
					</ul>
					<table>
						<thead>
							<tr>
								<th>Akcja</th>
								<th>Metoda HTTP</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><b>C</b>REATE</td>
								<td>POST</td>
							</tr>
							<tr>
								<td><b>R</b>ETRIEVE</td>
								<td>GET</td>
							</tr>
							<tr>
								<td><b>U</b>PDATE</td>
								<td>PUT</td>
							</tr>
							<tr>
								<td><b>D</b>ELETE</td>
								<td>DELETE</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>RESTful API</h3>					
				<pre><code class="Java" data-trim contenteditable>
@RequestMapping(path = "/cars", method = RequestMethod.GET)
public List&lt;CarTo&gt; findAllCars() { ... }

@RequestMapping(path = "/car", method = RequestMethod.POST)
public CarTo addCar(@RequestBody CarTo car) { ... }

@RequestMapping(path = "/car", method = RequestMethod.PUT)
public CarTo updateCar(@RequestBody CarTo car) { ... }

@RequestMapping(path = "/car/{id}", method = RequestMethod.DELETE)
public boolean deleteCar(@PathVariable("id") Long id) { ... }
					</code></pre>
					<ul>
						<li><a href="http://www.thomas-bayer.com/sqlrest/CUSTOMER/1">Przykład GET 1</a>
						<li><a href="http://jsonplaceholder.typicode.com/posts/1/comments">Przykład GET 2</a>
					</ul>
				</section>
				
				
				<!--     ZADANIE DO WYKONANIA Rest 
					a.	Przejść na branch step-2
					b.	Uruchomić aplikację poprzez klasę BooksServerApplication
					c.	Zwrócić uwagę na komunikat błędu i dodać brakującą implementację dla BookService
					d.	Ponownie uruchomić aplikację
					e.	W przeglądarce przejść na stronę localhost:8888/services/books?title=<tytul>&author=<author>
					f.	Zweryfikować wynik
					g.	Doimplementować listę książek i metodę wyszukiwania w tej liście
					h.	Ponownie wystartować aplikację i przejść na stronę localhost:8888/services/books?title=<tytul>&author=<author>
					i.	Poprzez różne wartości dla parametrów tytuł i autor zweryfikować działanie wyszykiwania.
				-->
				<section>
					<h4>ZADANIE: have a REST... Service</h4>
					<small>
					<ol>
						<li>Przejść na branch step-2
						<li>Uruchomić aplikację poprzez klasę BooksServerApplication
						<li>Zwrócić uwagę na komunikat błędu i dodać brakującą implementację dla BookService
						<li>Ponownie uruchomić aplikację
						<li>W przeglądarce przejść na stronę <i>localhost:8888/services/books?title=&lt;tytul&gt;&author=&lt;author&gt;</i>
						<li>Zweryfikować wynik
						<li>Doimplementować listę książek i metodę wyszukiwania w tej liście
						<li>Ponownie wystartować aplikację i przejść na stronę <i>localhost:8888/services/books?title=&lt;tytul&gt;&author=&lt;author&gt;</i>
						<li>Poprzez różne wartości dla parametrów tytuł i autor zweryfikować działanie wyszykiwania.
					</ol>
					</small>
				</section>
				
				
				<!--     Relacyjne bazy danych a świat obiektowy     -->
				<section>
				<h4>Relacyjne bazy danych a świat obiektowy</h4>
					<ul>
						<li>Aplikacje tworzą, zarządzają i przechowują informacje strukturalne
						<li>Programiści wybierają języki obiektowe
						<li>Zapisywanie i pobieranie danych wymaga znajomości SQL	
					</ul>
					
					<img src="images/objectVSsql.PNG" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<!--     Dostęp do danych za pomocą JDBC     -->
				
				<section>
				<h3>Dostęp do danych za pomocą JDBC</h3>
					<ul>
						<li>Bardzo dobrze znane API
						<li>Wymaga dobrej znajomości SQL
						<li>Łącze do baz danych dla języka Java	
					</ul>
					
					<img src="images/jdbc.png" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h3>JDBC - jak to działa</h3>
				
					<pre><code class="Java" data-trim>
@Service public class CustomerServiceImpl {

   private static final String FIND_ALL_LIBRARIES_IN_CITY_SQL =
      "SELECT l.id, l.name, l.address_id FROM Library l, Address a 
       WHERE l.address_id = a.id AND a.city = :city";
   
   @Autowired private NamedParameterJdbcOperations jdbcTemplate;
   @Autowired private LibraryRowMapper mapper;
   
   public List&lt;LibraryTO&gt; findAllLibrariesInCity (String cityName) {
      SqlParameterSource params = new MapSqlParameterSource("city", cityName);
      return jdbcTemplate.query(FIND_ALL_LIBRARIES_IN_CITY_SQL, params, mapper);
   }
					</code></pre>				
				
					<ul>
						<li>Konieczność definiowania zapytań SQL
						<li>Spring NamedParameterJdbcOperations do wykonywania instrukcji SQL
						<li>Spring RowMapper do mapowania wyniku zapytania na obiekt	
					</ul>
				</section>
				
				
				<section>
				<h3>JDBC - spring RowMapper</h3>
				Implementacja interfejsu RowMapper
					<pre><code class="Java" data-trim>
@Component
public class LibraryRowMapper implements RowMapper&lt;LibraryTO&gt; {

   @Override
   public LibraryTO mapRow(ResultSet rs, int rowNum) throws SQLException {
      LibraryTO library = new LibraryTO();
      library.setId(rs.getLong(1));
      library.setName(rs.getString(2));
      library.setAddress(mapAddressById(rs.getLong(3)));
      return library;
   }
   
   private AddressTO mapAddressById(Long addressId) {
      if (addressId != null && Long.compare(0, addressId) != 0)
        return new AddressTO(addressId));
      return null;
   }
					</code></pre>				
				</section>
				
				<section>
				<h3>JDBC - wady</h3>
					<ul>
						<li>Wymaga pisania dużej ilości dodatkowego kodu
						<li>Trudne mapowanie wyniku SQL na obiekty biznesowe
						<li>Kod związany z trwałością danych narażony na błędy programistów
						<li>Brak przenośności kodu, implementacja zależna od bazy danych
						<li>Implementacja bardzo trudna w utrzymaniu
						<li>Ewentualne błędy w zapytaniach SQL widoczne dopiero w trakcie działania programu
						<li>Kod nietestowalny
					</ul>
				</section>				
				
				<!--     Odwzorowanie obiektowo-relacyjne     -->
				
				<section>
				<h3>Odwzorowanie obiektowo-relacyjne</h3>
					<ul>
						<li>Przekształcenie obiektów w encje bazy danych i odwrotnie
 						<li>Przekształcenie połączeń między obiektami na relacje bazy danych
 						<li>Przekształcenie obiektowego języka zapytań na SQL
 						<li>Spójny sposób obsługi różnych baz danych - przenośność
 						<li>Zapewnienie trwałości obiektów
 						<li>Ochrona programisty przed czasochłonnym SQL-em
 						<li>Pozwala skupić się na implementacji logiki biznesowej
 						<li>Zapewnienie stałych technik optymalizacyjnych
 						<li>Oddzielenie warstwy dostępu do danych od biznesu
					</ul>
				</section>
				
				<section>
				<h4>Odwzorowanie obiektowo-relacyjne</h4>
				Niedopasowanie paradygmatów relacyjno-obiektowych	
					<table>
						<thead>
							<tr>
								<th>Podobieństwa</th>
								<th>Różnice</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Klasy i tabele</td>
								<td>Szczegółowość</td> 
							</tr>
							<tr>
								<td>Właściwości i kolumny</td>
								<td>Dziedziczenie (java)</td> 
							</tr>
							<tr>
								<td>Instancje i wiersze</td>
								<td>Kolekcje (java)</td> 
							</tr>
							<tr>
								<td></td>
								<td>Identyczność (==, equals vs PK)</td> 
							</tr>
							<tr>
								<td></td>
								<td>Nawigacja po grafie obiektów</td> 
							</tr>
						</tbody>
					</table>
					<p class="fragment">Podstawowym zadaniem ORM jest rozwiązanie wrodzonych niezgodności pomiędzy obiektami i bazami danych</p>
				</section>
				
				<section>
				<h3>Hibernate</h3>
					<ul>
						<li>Gavin King rozpoczął prace nad biblioteką pod koniec 2001 roku
						<li>Zespół na bieżąco realizował prośby użytkowników
						<li>Zgodny ze standardem JPA**
						<ul>
							<li>Możliwość traktowania Hibernate jako dostawcy trwałości
							<li>Możliwość używania bibliotek JPA, takich jak np. Spring-Data-Jpa
						</ul>
						<li>Oddziela kod biznesowy od warstwy dostepu do danych
					</ul>
				</section>		
				
				<section>
				<h3>Hibernate a development</h3>
					<img src="images/hibernate_development_tooling.jpg" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h3>TODO? - Hibernate a JPA</h3>
				</section>
				
				<section>
				<h3>TODO? - Mapowanie JPA</h3>
				</section>
				
				<section>
				<h3>Encja a <b>POJO</b></h3>
				
									<pre><code class="Java" data-trim>
public class LibraryEntity {
	private String name;
	private String domain;

	public LibraryEntity () {
	}

	public String getName() { return name; }

	public void setName(String name) { this.name = name; }
	
	public String getDomain() { return domain; }

	public void setDomain(String domain) { this. domain = domain; }
}
					</code></pre>
				</section>
				
				<section>
				<h3><b>Encja</b> a POJO</h3>
				
									<pre><code class="Java" data-trim>
@Entity
public class LibraryEntity {

	@Id
	private Long id;
	
	@Column(name = "name", length = 30, nullable = false)
	private String name;
	
	@Column(name = "domain", length = 5, nullable = true)
	private String domain;
	
	public LibraryEntity () {
	}
	
	// getters and setters
}

					</code></pre>
				</section>
				
				<section>
				<h4>Adnotacje dla Encji</h4>
				
									<pre><code class="Java" data-trim>
@Entity
@Table(name = "LIBRARY", schema = "public")
@Access(AccessType.FIELD)
public class LibraryEntity {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Long id;
	
	@Column(name = "name", length = 30, nullable = false)
	private String name;
	
	@Lob
	@Column(nullable = false)
	private String description;
	
	private String city;
	
	@Access(AccessType.PROPERTY)
	public String getCity ()  { ... }
	
	public LibraryEntity ()  { }
	
}
					</code></pre>
				</section>
				
				<section>
				<h4>Adnotacje dla Encji</h4>
					<ul>
						<li><b>@Entity</b> - oznacza klasę, odzwierciedla tabelę BD
						<li><b>@Entity(name="…")</b> - nigdy nie używać
						<li><b>@Access</b> - decyduje gdzie umieszczać adnotacje
						<li><b>@Table</b> - zmienia domyślną nazwę tabeli BD
						<li><b>@Id</b> - oznacza atrybut jako klucz główny
						<li><b>@GeneratedValue</b> - auto generacja wartości PK
						<li><b>@Column</b> - pozwala ustawić wartości kolumny
						<li><b>@Lob</b> - typ dla dużych danych tekstowych
						<li><b>@Enumerated(EnumType.STRING)</b> - enumy
						<li><b>@Transient</b> - wyłączenie pola z persystencji
						<li><b>@MappedSuperclas</b> - zwykłe dziedziczenie
					</ul>
				</section>
				
				<section>
				<h4>Typy Embedded</h4>
					<pre><code class="Java" data-trim>
@Embeddable
public class PersonalData  {

 private String firstName;
 
 private String lastName;
 
 @Column (columnDefinition=" DATE", nullable = false)
 private Date birthDate;

 public PersonalData()  {
 }
 
 // getters & setters     
 
}
					</code></pre>
				</section>
				
				<section>
				<h4>Typy Embedded</h4>
					<pre><code class="Java" data-trim>
@Entity
public class AuthorEntity  {

  @Embedded
  @AttributeOverrides({
       @AttributeOverride(
           name = "firstName", 
           column = @Column(
              name = "FIRST_NAME", 
              nullable = false)),
       @AttributeOverride(
           name = "lastName",
           column = @Column(
       	      name = "LAST_NAME", 
       	      nullable = false))})
  vate PersonalData personalData;
  
  ...
}
					</code></pre>
				</section>
				
				<section>
				<h3>Generowanie kluczy głównych - Strategie</h3>
					<pre><code class="Java" data-trim>
					
   @Id
   @GeneratedValue(strategy = GenerationType.AUTO)
   private Long id;
					</code></pre>
					<pre><code class="Java" data-trim>
					
   @Id
   @SequenceGenerator(name = "bookGen", sequenceName = "BOOK_SEQ")
   @GeneratedValue(strategy = GenerationType.SEQUENCE, 
					generator = "bookGen")
   private Long id;
					</code></pre>
				</section>
				
				<section>
				<h3>Generowanie kluczy głównych - Strategie</h3>
					<pre><code class="Java" data-trim>
					
    @Id
    @TableGenerator(
         name="bookGen",
         table="ID_GEN", // opcjonalnie
         pkColumnName="GEN_KEY", // opcjonalnie
         valueColumnName="GEN_VALUE", // opcjonalnie
         pkColumnValue="BOOK_ID_GEN") // opcjonalnie
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "bookGen")
    private Long id;
					</code></pre>
				</section>
				
				<section>
				<h3>Cykl życia encji</h3>
					<ul>
						<li>Adnotacje jako metadane opisujące mapowanie pomiędzy obiektem a bazą
						<li>Cykle życia encji:
						<ul>
							<li><b>nowy</b> (new) - brak identyfikatora i powiązania z kontekstem persystencji
							<li><b>zarządzany</b> (managed) – encja posiada ID i jest powiązana z kontekstem persystencji
							<li><b>odłączony</b> (detached) – encja posiada ID ale nie jest powiązana z kontekstem persystencji
							<li><b>usunięty</b> (removed) – tak jak zarządzany, ale oznaczona jako „do usunięcia”
						</ul>
					</ul>
				</section>
				
				<section>
				<h3>Listenery</h3>
					<ul>
						<li><b>@PrePersist</b>
						<li><b>@PostPersist    </b>
						<li><b>@PreUpdate      </b>
						<li><b>@PostUpdate     </b>
						<li><b>@PostLoad       </b>
						<li><b>@PreRemove      </b>
						<li><b>@PostRemove     </b>
					</ul>
				</section>
				
				<section>
				<h3>Listenery wewnątrz encji</h3>
					<pre><code class="Java" data-trim>
@Entity
@Table(name = "CUSTOMER_CARD")
public class CustomerCardEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
	
    @Column(nullable = false)
    private String serialNumber;

    @PrePersist
    public void generateDefaultSerialNumber() {
        serialNumber = new SerialNumberGenerator().generate();
    }
}
					</code></pre>
				</section>
				
				<section>
				<h3>Listenery stand alone</h3>
					<pre><code class="Java" data-trim>
@Entity
@Table(name = "CUSTOMER_CARD")
@EntityListeners(CustomerCardListener.class)
public class CustomerCardEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
	
    @Column(nullable = false)
    private String serialNumber;

}
					</code></pre>
				</section>
				
				<section>
				<h3>Listenery stand alone</h3>
					<pre><code class="Java" data-trim>
public class CustomerCardListener  {

    @PrePersist
    public void generateDefaultSerialNumber
			(CustomerCardEntity customerCardEntity) {
        String serialNumber = new SerialNumberGenerator().generate();
        customerCardEntity.setSerialNumber(serialNumber);
    }
	
}
					</code></pre>
				</section>
				
				<section>
				<h4>Entity Manager</h4>
					<ul>
						<li>Podstawowy element całej warstwy persystencji
						<li>Zarządza transakcjami i encjami
					</ul>
				
				
									<pre><code class="Java" data-trim>
String unitName = "MyPersistenceUnit";

// utwórz
EntityManagerFactory emf = Persistence.createEntityManagerFactory(unitName);
EntityManager em = emf.createEntityManager();

// zrób co masz do zrobienia
zrobCos(em);

// zamknij
em.close();
emf.close();
					</code></pre>
				</section>
				
				<section>
				<h4>Entity Manager - dostęp do danych</h4>
					<ul>
						<li>Podstawowy element całej warstwy persystencji
						<li>Zarządza transakcjami i encjami
					</ul>
									<pre><code class="Java" data-trim>
// zapis
Product banan = new Product(1, "banan", "owoce");
em.persist(banan);

// odczyt
Product bananFromDB = em.find(Product.class, 1);

// usunięcie
Product bananFromDB = em.find(Product.class, 1);
em.remove(bananFromDB);

// zapytanie
Product product = em.createQuery(
"SELECT p FROM Product p WHERE p.category = :cat_param", Product.class)
	.setParameter("cat_param", "owoce")
	.getSingleResult();

					</code></pre>
				</section>
				
				<section>
				<h3>Relacje</h3>
					<ul>
						<li><b>@OneToOne</b> – encja A może mieć relację do dokładnie jednej encji B
						<li><b>@OneToMany</b> – encja A może mieć relację do kilku encji B
						<li><b>@ManyToOne</b> – wiele encji A może mieć relację do dokładnie jednej encji B
						<li><b>@ManyToMany</b> – wiele encji A może mieć relację do wielu encji B
						<ul><li>Tworzy tabelę asocjacyjną</ul>
					</ul>
				</section>	
				
				<section>
				<h3>Relacje</h3>
					<ul>
						<li>Wyróżniamy relacje:
						<ul>
							<li>jednokierunkowe
							<li> dwukierunkowe
						</ul>
					</ul>
				</section>
				
				<section>
				<h3>@OneToOne - jednokierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class User {

	@OneToOne(
		cascade = CascadeType.ALL, // default: empty
		fetch = FetchType.LAZY, // default: EAGER
		optional = false) // default: true
	private Address address;
}
					</code></pre>
				<pre><code class="Java" data-trim>
@Entity
public class Address {
}

					</code></pre>
				</section>
								
				<section>
				<h3>@OneToOne - dwukierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class User {

	@OneToOne
	@JoinColumn(name = "BOOK_FK")
	private Address address;
}

					</code></pre>
				<pre><code class="Java" data-trim>
@Entity
public class Address {

	@OneToOne(mappedBy = „address”)
	private User user;
}
					</code></pre>
					<ul>
						<li><b>mappedBy</b> określa właściciela relacji
						<li>użytkownik ma klucz obcy do adresu
						<li>bez mappedBy klucz obcy po obu stronach
					</ul>
				</section>
				
				<section>
				<h3>@OneToMany / @ManyToOne - jednokierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class User {

	@OneToMany(
	cascade = CascadeType.ALL, // default: empty
	fetch = FetchType. EAGER) // default: LAZY
	@JoinColumn(name = "user_id")
	private Collection&lt;Address&gt; addresses;
}

					</code></pre>
				<pre><code class="Java" data-trim>
@Entity
public class Address {
}
					</code></pre>
					<ul>
						<li>bez <b>@JoinColumn</b> utworzona zostanie tabela asocjacyjna
					</ul>
				</section>
				
				
				
				<section>
				<h3>@OneToMany / @ManyToOne - dwukierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class User {

	@OneToMany(mappedBy = "user")
	private Collection&lt;Address&gt; addresses;
}

					</code></pre>
				<pre><code class="Java" data-trim>
@Entity
public class Address {

	@ManyToOne
	@JoinColumn(name = "BOOK_FK", nullable = false)
	private User user;
}
					</code></pre>
					<ul>
						<li>mappedBy tak samo jak <b>@JoinColumn</b> usuwa tabelę asocjacyjną
					</ul>
				</section>
				
				<section>
				<h3>@ManyToMany - jednokierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class User {

	@ManyToMany(
		cascade = CascadeType.ALL, // default: empty
		fetch = FetchType. LAZY) // default: EAGER    
	@JoinTable(name = "USER_ADDRESS",
		joinColumns = {@JoinColumn(
			name = "BOOK_ID", 
			nullable = false, 
			updatable = false)},
		inverseJoinColumns = {@JoinColumn(
			name = "AUTHOR_ID", 
			nullable = false, 
			updatable = false)})
	private Collection&lt;Address&gt; addresses;
}
					</code></pre>
				</section>
				
				<section>
				<h3>@ManyToMany - dwukierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class Address {

    @ManyToMany(mappedBy = "book")
    private Collection&lt;User&gt; users;
}
					</code></pre>

					<ul>
						<li>bez mappedBy dwie tabele asocjacyjne zostaną stworzone
					</ul>
				</section>
				
				<section>
				<h3>Kaskady</h3>
					<ul>
						<li>Entity Manager dokonuje zmian na danej encji, np. persist
						<li>Kaskady umożliwiają operację na encji połączonej relacją
						<ul>
							<li><b>PERSIST      </b>
							<li><b>MERGE        </b>
							<li><b>REMOVE       </b>
							<li><b>ALL          </b>
						</ul>
					</ul>				
				</section>
				
				<section>
				<h3>Kaskady</h3>
				<pre><code class="Java" data-trim>
@Entity
@Table(name = "BOOK")
public class BookEntity  {

    @OneToOne(cascade = CascadeType.ALL, mappedBy = "book")
    private BookSpoilerEntity bookSpoiler;
	
}
					</code></pre>			
				</section>
				
				<section>
				<h3>Dziedziczenie</h3>
					<ul>
						<li>Naturalna właściwość obiektów
						<li>Nie ma zastosowania w relacyjnych bazach danych
						<li>Rozwiązaniem Hibernate są trzy strategie:
						<ul>
							<li><b>SINGLE_TABLE        </b>
							<li><b>TABLE_PER_CLASS       </b>
							<li><b>JOINED          </b>
						</ul>
						<li>Możliwość wykonywania zapytań polimorficznych
					</ul>	
				</section>
				
				<section>
				<h3>Strategie: Single Table</h3>
					<ul>
						<li>Podobne obiekty przechowywane są w jednej tabeli
						<li>Rekordy rozróżniane są przez tzw. Dyskryminator
						<li>Wydajne wyszukiwanie – brak złączeń
						<li>Puste kolumny (różnice między obiektami)
						<li>Problem z warunkiem Not-Null. 
					</ul>	
				</section>
				
				<section>
				<h3>Strategie: Single Table</h3>
				<pre><code class="Java" data-trim>
@Entity
@Table(name = "AUTHOR")
@DiscriminatorColumn(name = "TYPE", length = 6, 
		discriminatorType = DiscriminatorType.STRING)
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public abstract class AuthorEntity  {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    protected Long id;
	
    @Column(nullable = true, length = 30)
    protected String nickName;

}
					</code></pre>			
				</section>
				
				<section>
				<h3>Strategie: Single Table</h3>
				<pre><code class="Java" data-trim>
@Entity
@DiscriminatorValue("WRITER")
public class WriterEntity extends AuthorEntity  {

    @Enumerated(EnumType.STRING)
    private LiteraryGenre literaryGenre;
	
}
					</code></pre>	
				</section>
				
				<section>
				<h3>Strategie: Single Table</h3>
				<pre><code class="Java" data-trim>
@Entity
@DiscriminatorValue("PROFES")
public class ProfessorEntity extends AuthorEntity  {

    @Column(nullable = true)
    private String university;

}
					</code></pre>	
				</section>
				
				<section>
					<h3>Strategie: Single Table</h3>
					<img src="images/inheritance_single_table_db.png" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h3>Strategie: Table per class</h3>
					<ul>
						<li>Oddzielna tabela bazy danych na jedną encję
						<li>Brak porblemów z warunkami Not-Null
						<li>Redundancja wspólnych atrybótów
						<li>Niewydajne zapytania SQL przy zapytaniach polimorficznych 

					</ul>
				</section>
				
				<section>
				<h3>Strategie: Joined</h3>
					<ul>
						<li>Bazowe obiekty zapisane są w jednej tabeli
						<li>Różnice między obiektami zapisywane są w oddzielnych tabelach
						<li>Znormalizowana baza danych
						<li>Brak redundancji
						<li>Wymagane złączenie tabel przy zapytaniach polimorficznych
					</ul>
				</section>
				
				<section>
				<h3>Strategie: Joined</h3>
				<pre><code class="Java" data-trim>
@Entity
@Table(name = "BOOK_EXEMPLAR")
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class BookExemplarEntity  {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    protected Long id;
	
    @Column(nullable = false, length = 15, unique = true)
    protected String serialNumber;
}
					</code></pre>	
				<img src="images/inheritance_joined_db_1.png" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h3>Strategie: Joined</h3>
				<pre><code class="Java" data-trim>
@Entity
@Table(name = "PAPER_BOOK")
@PrimaryKeyJoinColumn(name = "book_ex_id", referencedColumnName = "id")
public class PaperBookExemplarEntity extends BookExemplarEntity  {

    private int pagesCount;
	
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PaperSize paperSize;
	
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private BookCover bookCover;
}
					</code></pre>	
				<img src="images/inheritance_joined_db_2.png" style="background:none; border:none; box-shadow:none;">
				</section>				
				
				<!--     ZADANIE DO WYKONANIA BookEntity 
					a.	Przejść na branch step-3
					b.	Zaznajomić się z modelem encji
					c.	Uruchomić test BookServiceImplTest i sprawdzić wyniki
					d.	Poprawić mapowanie JPA dla encji
					e.	Uruchomić ponownie test BookServiceImplTest i zweryfikować poprawność wszystkich przypadków testowych
				-->				
				<section>
					<h4>ZADANIE: Annotation processing</h4>
					<small>
					<ol>
						<li>Przejść na branch step-3
						<li>Zaznajomić się z modelem encji
						<li>Uruchomić test BookServiceImplTest i sprawdzić wyniki
						<li>Poprawić mapowanie JPA dla encji
						<li>Uruchomić ponownie test BookServiceImplTest i zweryfikować poprawność wszystkich przypadków testowych
					</ol>
					</small>
				</section>
				
				
				<!--     DAO     -->
				
				<section>
				<h3>Oddzielenie logiki domeny od obsługi trwałości</h3>
				<h4>Zastosowanie wzorca Data Access Object (DAO)</h4>
				<img src="images/dao.PNG" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h4>Dao - interfejs</h4>
				
									<pre><code class="Java" data-trim>
public interface Dao&lt;T&gt; {

	void create(T entity);
	T get(Serializable id);
	T load(Serializable id);
	List&lt;T&gt; getAll();
	void update(T entity);
	void saveOrUpdate(T entity);
	void delete(T entity);
	void delete(Serializable id);
	void deleteAll();
	long count();
	boolean exists(Serializable id);

}
					</code></pre>
				</section>				
				
				<section>
				<h4>Dao - implementacja</h4>
				
									<pre><code class="Java" data-trim>
@Transactional(Transactional.txType.SUPPORTS)
public abstract class AbstractDao&lt;T&gt; implements Dao&lt;T&gt; {
   
   @Autowired
   private SessionFactory sessionFactory;
   private Class&lt;T&gt; domainClass;
   
   protected Session getSession() { 
      return sessionFactory.getCurrentSession();
   }
   
   @Override
   public void create(T entity) {
      getSession().save(entity);
   }
   
   @Override
   @SuppressWarnings("unchecked")
   public T get(Serializable id) {
      return (T) getSession().get(getDomainClass(), id);
   }
   
   @Override
   public List&lt;T&gt; getAll() {
      return getSession().createQuery("from " + getDomainClassName()).list();
   }
}
					</code></pre>
				</section>		
				
				<section>
				<h4>Dao - implementacja</h4>
				
									<pre><code class="Java" data-trim>
@Repository
public class LibraryDaoImpl extends AbstractDao&lt;LibraryEntity&gt; {
   
   @SuppressWarnings("unchecked")
   public List&lt;LibraryEntity&gt; findByName(String name) {
      return getSession()
         .createQuery("from LibraryEntity l where l.name like :name")
         .setString("name", name + "%")
         .list();
   }
}
					</code></pre>
				</section>	
				
				<section>
				<h3>Obiekty DAO</h3>
					<ul>
						<li>Stanowią interfejs do komunikacji aplikacji z bazą danych
						<li>Nie zawierają logiki biznesowej
						<li>Oddzielają logikę biznesową od dostępu do danych
						<li>Powodują powstanie kolejnej warsty w aplikacji
					</ul>
					<p class="fragment">No to jaka właściwie jest różnica między DAO a Repository?</p>
				</section>
				
				
				<!--     ZADANIE DO WYKONANIA BookDao  
					a.	Przejść na branch step-4
					b.	Zrealizuj wyszukiwanie książek dla zadanych kryteriów z wykorzystaniem Criteria API
					c.	Podążaj za wskazówkami prowadzącego. (live coding)
				-->	
				<section>
					<h4>ZADANIE: Find it</h4>
					<small>
					<ol>
						<li>Przejść na branch step-4
						<li>Zrealizuj wyszukiwanie książek dla zadanych kryteriów z wykorzystaniem Criteria API
						<li>Podążaj za wskazówkami prowadzącego. (live coding)
					</ol>
					</small>
				</section>
				
				
				<!--     Transakcje     -->
				
				<section>
				<h3>Transakcje</h3>
					<ul>
						<li>Zbiór operacji na bazie danych stanowiących jedną całość
 						<li>Zmieniają spójny stan bazy danych w inny spójny stan
 						<li>Cechy transakcji:
						<ul>
							<li>Atomowość (<b>A</b>tomicity)
							<li>Spójność (<b>C</b>onsistency)
							<li>Izolacja (<b>I</b>soation)
							<li>Trwałość (<b>D</b>urability)	
						</ul>
					</ul>
				</section>
				
				<section>
				<h4>Transakcje - Entity Manager</h4>
				
									<pre><code class="Java" data-trim>
// rozpoczyna transakcję
em.getTransaction().begin();

// wykonanie operacji
Product prodFromDb = em.find(Product.class, 1);
prodFromDb.setCategory("newCategory");

// zatwierdzenie transakcji
em.getTransaction().commit();

// ewentualne wycofanie transakcji
em.getTransaction().rollback();
					</code></pre>
				</section>
				
				<section>
				Transakcje Spring <b>@Transactional</b>
				
					<ul>
						<li>Najlepszy sposób budowania transakcyjnych aplikacji Spring 
 						<li>Brak powielonego kodu
						<li>Bardzo łatwa konfiguracja
						<li>Propagacja, izolacja, timeout, readOnly, rollbackFor itp.
						<li>Możliwość zdefiniowania na całej klasie i metodzie
					</ul>
				</section>	

				<section>
				<h4>@Transactional</h4>
				
									<pre><code class="Java" data-trim>
@Service
@Transactional(readOnly = true)
public class LibraryServiceImpl implements LibraryService {

	@Autowired
	private LibraryRepository libraryRepository;
	
	@Autowired
	private MapperFacade mapper;
	
	@Override
	public List&lt;LibraryTO&gt; findAllLibraries () {
		List&lt;LibraryEntity&gt; libraries = libraryRepository.findAll();
		return mapper.mapAsList(libraries, LibraryTO.class);
	}
}
					</code></pre>
				</section>				
				
				<section>
				<h3>TODO? - Przyklad z XMLem?</h3>
				</section>
										
				<section>
				<h3>Flyway</h3>
                  <ul>
                      <li>Narzędzie do płynnej migracji bazy danych</li>
                      <li>Umożliwia kontrolę wersji bazy danych poprzez skrypty migracyjne</li>
                      <li>Skrypty migracyjne są wykonywane po czym w specjalnej tabeli zapisane są ich skróty</li>
				      <li>Dostęp poprzez API, plugin Mavena oraz narzędzie CLI</li>
                      <img src="images/flyway.PNG" style="background:none; border:none; box-shadow:none;">
					</ul>			
				</section>
				
				
				<!--     ZADANIE DO WYKONANIA BookService   
					a.	Przejść na branch step-5
					b.	Zaimplementuj metodę save w klasie BookServiceImpl
					c.	Zaimplementuj mapper przepisujący atrybuty z obiektu TO do encji.
					d.	Zapewnij transakcyjność metody używając w odpowiednim miejscu adnotacji @Transactional
					e.	Zweryfikuj działanie testów BookServiceImplTest
				-->
				<section>
					<h4>ZADANIE: Save it</h4>
					<small>
					<ol>
						<li>Przejść na branch step-5
						<li>Zaimplementuj metodę save w klasie BookServiceImpl
						<li>Zaimplementuj mapper przepisujący atrybuty z obiektu TO do encji.
						<li>Zapewnij transakcyjność metody używając w odpowiednim miejscu adnotacji @Transactional
						<li>Zweryfikuj działanie testów BookServiceImplTest
					</ol>
					</small>
				</section>
				
				
				<!--     Testy     -->
				<section>
				<h3>Po co testy?</h3>
				
				</section>
				<section>
				<h3>Jakie testy warto tworzyć</h3>
					<ol>
						<li>Jednostkowe
						<li>Integracyjne	
						<li>Komponentowe
						<li>E2E
						<li>Akceptacyjne
					</ol>
					<p>
					<small><a href="https://en.wikipedia.org/wiki/Software_testing">Wikipedia</a></small>
					</p>
				</section>
				
				<section>
				<h3>Jakie narzędzia wykorzystywać przy tworzeniu testów</h3>
					<ol>
						<li>Mockowanie zależności
						<li>Asercje
						<li>given-when-then
						<li>Continuous Integration
						<li>Argument Captors
						<li>...
					</ol>
				</section>
				
				<section>
				<h3>Test Jednostkowy z wykorzystaniem MockMVC</h3>
				<pre><code class="Java" data-trim>		
@EnableWebMvc
@ComponentScan("org.itsurvival.books.rest")
public static class BooksRestServiceTestConfiguration {

    @Bean
    public BookService bookService() {
        return Mockito.mock(BookService.class);
    }
}

private MockMvc mockMvc;

@Autowired
private WebApplicationContext webApplicationContext;

@Autowired
private BookService bookService;

@Captor
private ArgumentCaptor&lt;BookSearchCriteria&gt; bookSearchCriteriaCaptor;

@Captor
private ArgumentCaptor&lt;BookTo&gt; bookCaptor;
				
@Test
public void shouldAddNewBook() throws Exception {

    // given
    byte[] content = readFileToBytes(
		"classpath:org/itsurvival/books/rest/newBook.json");

    when(bookService.addBook(any(BookTo.class)))
		.thenAnswer(args -> args.getArguments()[0]);

    // when
    mockMvc.perform(post("/services/book")
			.content(content)
			.contentType(MediaType.APPLICATION_JSON))
            // then
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.title", is("Test title")));


    verify(bookService).addBook(bookCaptor.capture());
    BookTo book = bookCaptor.getValue();
    assertThat(book.getTitle()).isEqualTo("Test title");
    assertThat(book.getAuthor()).isEqualTo("Test author");
    assertThat(book.getYear()).isEqualTo(2008);
    assertThat(book.getGenre()).isEqualTo(Genre.IT);
    assertThat(book.getVersion()).isEqualTo(0L);
    assertThat(book.getId()).isNull();
}
				</code></pre>
				</section>
				
				
				<!--     ZADANIE DO WYKONANIA Mockito  
					a.	Przejść na branch step-6
					b.	Zapoznaj się z implementacją BookRestServiceTest
					c.	Brakuje w niej implementacji pewnych testów.
					d.	Dodaj ciała brakujących testów bazując na przykładach pozostałych metod.
				-->
								
				<section>
					<h4>ZADANIE: Test it</h4>
					<small>
					<ol>
						<li>Przejść na branch step-6
						<li>Zapoznaj się z implementacją BookRestServiceTest
						<li>Brakuje w niej implementacji pewnych testów.
						<li>Dodaj ciała brakujących testów bazując na przykładach pozostałych metod.
					</ol>
					</small>
				</section>
				
												
				<section>
					<h2>Pytania ?</h2>
					
					<h2>Feedback !</h2>
					
				</section>
				
				
				<!-- TO DO
				19.	Optimistic Locking 
				20.	Zapytania polimorficzne
				21.	Query DSL
				22.	Cache 
				23. orphan removal
				24. envers
				-->

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', 

				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
