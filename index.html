<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>VIP Academy – Backend</title>

		<meta name="description" content="Slides for the presentation">
		<meta name="author" content="asdf">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section>
					<h1>VIP Academy</h1>
					<h3>Backend</h3>
				</section>

				<section>
					<h2>Agenda</h2>
					<ol>
						<li><a href="#/2">Spring Framework</a></li>
						<li><a href="#/2">Maven</a></li>
						<li><a href="#/3">Spring Boot</a></li>
						<li><a href="#/4">Architektura wielowarstwowa</a></li>
						<li><a href="#/5">RESTful Services</a></li>
						<li><a href="#/6">Relacyjne bazy danych a świat obiektowy</a></li>
						<li><a href="#/7">Dostęp do danych za pomocą JDBC</a></li>
						<li><a href="#/8">Odwzorowanie obiektowo-relacyjne</a></li>
						<li><a href="#/9">DAO</a></li>
						<li><a href="#/10">Transakcje</a></li>
						<li><a href="#/11">Testy</a></li>
					</ol>
				</section>
				
				<!--     Spring Framework     -->
				
				<section>
					<h2>Spring Framework</h2>
					<ul>
						<li>Powstał w 2003 roku</li>						
						<li>Szkielet tworzenia aplikacji dla języka Java</li>
						<li>Alternatywa dla programowania w EJB</li>
						<li>Oferuje dużą swobodę wytwarzania oprogramowania</li>
						<li>Bardzo dobra dokumentacja</li>
						<li>Gotowa implementacja wielu zagadnień</li>
						<li>Ogromne wsparcie dla Java EE</li>
						<li>Propaguje poprawny styl programowania</li>
						<li>Jest dostępny na zasadach open source</li>
					</ul>
				</section>	
				
				<section>
					<h3>Spring Framework - moduły</h3>
					<ul>
						<li>Składa się z kilku niezależnych od siebie modułów</li>
						<li>Moduły można ze sobą łączyć w celu uzyskania większej funkcjonalności</li>
					</ul>
					<img src="images/spring_modules.png" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
					<h3>Spring Framework – podstawowy kontener</h3>
					<ul>
						<li>Core</li>
							<ul> <li>podstawowa część frameworka, zawiera IoC i wstrzykiwanie zależności</li> </ul>
						<li>Beans</li>
							<ul> 	
								<li>eliminuje potrzebę programowego tworzenia singletonów</li>
								<li>oddziela zależność pomiędzy konfiguracją, specyfikacją a logiką programu</li> 
							</ul>
					</ul>
				</section>	

				<section>
					<h3>Spring Framework – podstawowy kontener</h3>
					<ul>							
						<li>Context</li>
							<ul> 	
								<li>umożliwia dostęp do obiektów zarządzanych przez framework</li>
								<li>pozwala na wydzielenie konfiguracji do plików *.properties</li>
								<li>udostępnia interface ApplicationContext</li> 
							</ul>
						<li>EL - Spring Expression Language</li>
					</ul>
					<pre><code class="Java" data-trim contenteditable>
@Value("#{applicationProperties['jakas.zmienna.z.pliku.properties']}")
private String zmienna;
					</code></pre>
				</section>
				
				<section>
				<h3>TODO? - Jak zacząć ze springiem?</h3>
				</section>
				
				<section>
					<h3>Inversion of Control, Dependency Injection</h3>
					<ul>
						<li>Paradygmat programowania, wzorzec projektowy, wzorzec architektoniczny.
						<li>Zastosowanie 
							<ul>
								<li>w pojedynczych komponentach,
								<li>w architekturze całego systemu (Spring Framework)
							</ul>
						<li>W klasycznym podejściu obiekty są budowane statycznie, brak wpływu na ich postać.
						<li>Odwracamy kontrolę – budowaniem obiektów zajmuje się framework
					</ul>
				</section>
				
				
				<section>
					<h3>Inversion of Control, Dependency Injection</h3>
					<b>Wstrzykiwanie zależności</b> – dla danego obiektu definiujemy, z jakich innych komponentów będzie korzystał, ale nie musimy się martwić o tworzenie instancji tych obiektów – zrobi to za nas framework, wykorzystywane w Springu.
					
										<pre><code class="Java" data-trim contenteditable>
@Service
public class CustomerServiceImpl {

	private final CustomerMapper customerMapper;
	private final CustomerDao customerDao;
	
	@Autowired
	public CustomerServiceImpl (CustomerMapper mapper, CustomerDao dao) {
		this.customerMapper = mapper;
		this.customerDao = dao;
	}
					</code></pre>
					
				</section>
				
				<section>
				<h3>TODO? - Spring framework - podstawy</h3>
				Przyklady z kodu z cwiczen?
				</section>
				
				<section>
				<h3>Spring framework - adnotacje</h3>
					<ul>
						<li><b>@Component</b> - podstawowa adnotacja, określa że klasa jest zarządzana przez Spring
						<li><b>@Service</b> - określa klasę zawierającą logikę biznesową
						<li><b>@Repository</b> - klasy DAO (Data Access Object), bezpośrednia komunikacja z DB
					</ul>
					
						<p class="fragment">Wszystkie działają i robią to samo</p>
							<p class="fragment">Wyjątkiem jest @Repository, która dodatkowo konwertuje wyjątki dostawców bazy danych</p>
						<p class="fragment">Adnotacje pozwalają oddzielić od siebie różne warstwy aplikacji</p>
						<p class="fragment">Ułatwiają czytanie i analizowanie kodu</p>
				</section>
				
				<section>
				<h3>Spring framework - adnotacje</h3>
					<ul>
						<li><b>@Controller</b> - przetwarza żądania HTTP
						<li><b>@Scope</b> - umożliwia zmianę domyślnego czasu życia bean’a
						<li><b>@PostConstruct</b> - umożliwia wywołanie części kodu zaraz po utworzeniu obiektu
						<li><b>@RequestMapping</b> - używana w kontrolerze, mapuje adres URL na metodę
					</ul>
				</section>
				
				
				<!--     Maven     -->
				<section>
				<h3>Maven</h3>
                    <ul>
                      <li>Cel - Automatyzacja i standaryzacja procesu budowania</li>
                      <li>Umożliwia opis procesu budowania oprogramowania</li>
                      <li>Pozwala na zdefiniowanie zależności oraz zarządzanie nim</li>
                      <li>Centralne repozytorium artefaktów - search.maven.org</li>
                      <li>Lokalne repozytorium - zdef</li>
                    </ul>
				</section>
                <section>
                  <h3>Struktura projektu - convention over configuration</h3>
                  <img src="images/mvn.png" style="background:none; border:none; box-shadow:none;">
                </section>
              
                <section>
                  <h3>Konfiguracja projektu - POM (Project Object Model)convention over configuration</h3>
                  <img src="images/pom.png" style="background:none; border:none; box-shadow:none;">
                </section>
              
                <section>
                  <h3>Maven build lifecycle</h3>
                  <ul>
                      <li>Zadania wykonaywane kaskadowo - wykonanie konkretnego kroku powoduje również wykonanie wszystkich poprzedzających</li>
                      <li>mvn compile</li>
                      <li>Deweloper najczęściej używa mvn clean install</li>
                      <li>Poszczególne pluginy korzystają ze zdefiniownaych faz w celu wykonania własnej akcji, np. mvn surefire:test</li>
                  </ul>
                  <img src="images/mvn_build.png" style="background:none; border:none; box-shadow:none;">
                </section>
				
			    <section>
                  <h3>Zarządzanie zależnościami - dependency management</h3>
                  <ul>
                      <li>Każda biblioteka posiada unikalny identyfikator - groupId, artifactId, version</li>
                      <li>Plik pom.xml zawiera sekcję dependencyManagement z listą zależności</li>
                      <li>Zależności są aktualizowane w procesie budowania</li>
                      <li>Centralne repozytorium artefaktów - search.maven.org</li>
                      <li>Lokalne repozytorium - lokalizacja definiowana dla użytkownika</li>
                    </ul>
                  <img src="images/mvn_dependencies.png" style="background:none; border:none; box-shadow:none;">
                </section>  	
              
				<!--     Spring Boot     -->								
				<section>
				<h3>TODO? - Spring boot</h3>
				</section>				
								
				<section>
				<h3>TODO? - Spring boot / Startery</h3>
				</section>				
								
				<section>
				<h3>TODO? - Spring boot / embedded vs Classical Server</h3>
				</section>
				
				
				<!--     ZADANIE DO WYKONANIA start.spring.io     wyklikanie spring.io i rest z hello world -->
				<section>
				<h3>TODO? - zadanie do wykonania</h3>
				wyklikanie spring.io i rest z hello world
				</section>
				
				
				<!--     Architektura wielowarstwowa     -->
				<section>
				<h3>TODO? - Architektura wielowarstwowa</h3>
				</section>
				
				
				<!--     RESTful Services     -->
				<section>
				<h3>TODO? - RESTful Services</h3>
				</section>
				
				
				<!--     ZADANIE DO WYKONANIA Rest      -->
				<section>
				<h3>TODO? - zadanie do wykonania Lista obiektow, bez polaczenia z baza</h3>
				</section>
				
				
				<!--     Relacyjne bazy danych a świat obiektowy     -->
				<section>
				<h4>Relacyjne bazy danych a świat obiektowy</h4>
					<ul>
						<li>Aplikacje tworzą, zarządzają i przechowują informacje strukturalne
						<li>Programiści wybierają języki obiektowe
						<li>Zapisywanie i pobieranie danych wymaga znajomości SQL	
					</ul>
					
					<img src="images/objectVSsql.PNG" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<!--     Dostęp do danych za pomocą JDBC     -->
				
				<section>
				<h3>Dostęp do danych za pomocą JDBC</h3>
					<ul>
						<li>Bardzo dobrze znane API
						<li>Wymaga dobrej znajomości SQL
						<li>Łącze do baz danych dla języka Java	
					</ul>
					
					<img src="images/jdbc.png" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h3>JDBC - jak to działa</h3>
				
					<pre><code class="Java" data-trim>
@Service public class CustomerServiceImpl {

   private static final String FIND_ALL_LIBRARIES_IN_CITY_SQL =
      "SELECT l.id, l.name, l.address_id FROM Library l, Address a 
       WHERE l.address_id = a.id AND a.city = :city";
   
   @Autowired private NamedParameterJdbcOperations jdbcTemplate;
   @Autowired private LibraryRowMapper mapper;
   
   public List&lt;LibraryTO&gt; findAllLibrariesInCity (String cityName) {
      SqlParameterSource params = new MapSqlParameterSource("city", cityName);
      return jdbcTemplate.query(FIND_ALL_LIBRARIES_IN_CITY_SQL, params, mapper);
   }
					</code></pre>				
				
					<ul>
						<li>Konieczność definiowania zapytań SQL
						<li>Spring NamedParameterJdbcOperations do wykonywania instrukcji SQL
						<li>Spring RowMapper do mapowania wyniku zapytania na obiekt	
					</ul>
				</section>
				
				
				<section>
				<h3>JDBC - spring RowMapper</h3>
				Implementacja interfejsu RowMapper
					<pre><code class="Java" data-trim>
@Component
public class LibraryRowMapper implements RowMapper&lt;LibraryTO&gt; {

   @Override
   public LibraryTO mapRow(ResultSet rs, int rowNum) throws SQLException {
      LibraryTO library = new LibraryTO();
      library.setId(rs.getLong(1));
      library.setName(rs.getString(2));
      library.setAddress(mapAddressById(rs.getLong(3)));
      return library;
   }
   
   private AddressTO mapAddressById(Long addressId) {
      if (addressId != null && Long.compare(0, addressId) != 0)
        return new AddressTO(addressId));
      return null;
   }
					</code></pre>				
				
					
				</section>
				
				<section>
				<h3>JDBC - wady</h3>
					<ul>
						<li>Wymaga pisania dużej ilości dodatkowego kodu
						<li>Trudne mapowanie wyniku SQL na obiekty biznesowe
						<li>Kod związany z trwałością danych narażony na błędy programistów
						<li>Brak przenośności kodu, implementacja zależna od bazy danych
						<li>Implementacja bardzo trudna w utrzymaniu
						<li>Ewentualne błędy w zapytaniach SQL widoczne dopiero w trakcie działania programu
						<li>Kod nietestowalny
					</ul>
				</section>				
				
				<!--     Odwzorowanie obiektowo-relacyjne     -->
				
				<section>
				<h3>Odwzorowanie obiektowo-relacyjne</h3>
					<ul>
						<li>Przekształcenie obiektów w encje bazy danych i odwrotnie
 						<li>Przekształcenie połączeń między obiektami na relacje bazy danych
 						<li>Przekształcenie obiektowego języka zapytań na SQL
 						<li>Spójny sposób obsługi różnych baz danych - przenośność
 						<li>Zapewnienie trwałości obiektów
 						<li>Ochrona programisty przed czasochłonnym SQL-em
 						<li>Pozwala skupić się na implementacji logiki biznesowej
 						<li>Zapewnienie stałych technik optymalizacyjnych
 						<li>Oddzielenie warstwy dostępu do danych od biznesu
					</ul>
				</section>
				
				<section>
				<h4>Odwzorowanie obiektowo-relacyjne</h4>
				Niedopasowanie paradygmatów relacyjno-obiektowych	
					<table>
						<thead>
							<tr>
								<th>Podobieństwa</th>
								<th>Różnice</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Klasy i tabele</td>
								<td>Szczegółowość</td> 
							</tr>
							<tr>
								<td>Właściwości i kolumny</td>
								<td>Dziedziczenie (java)</td> 
							</tr>
							<tr>
								<td>Instancje i wiersze</td>
								<td>Kolekcje (java)</td> 
							</tr>
							<tr>
								<td></td>
								<td>Identyczność (==, equals vs PK)</td> 
							</tr>
							<tr>
								<td></td>
								<td>Nawigacja po grafie obiektów</td> 
							</tr>
						</tbody>
					</table>
					<p class="fragment">Podstawowym zadaniem ORM jest rozwiązanie wrodzonych niezgodności pomiędzy obiektami i bazami danych</p>
				</section>
				
				<section>
				<h3>Hibernate</h3>
					<ul>
						<li>Gavin King rozpoczął prace nad biblioteką pod koniec 2001 roku
						<li>Zespół na bieżąco realizował prośby użytkowników
						<li>Zgodny ze standardem JPA**
						<ul>
							<li>Możliwość traktowania Hibernate jako dostawcy trwałości
							<li>Możliwość używania bibliotek JPA, takich jak np. Spring-Data-Jpa
						</ul>
						<li>Oddziela kod biznesowy od warstwy dostepu do danych
					</ul>
				</section>		
				
				<section>
				<h3>TODO? - Hibernate - co daje -- mozliwe transformacje</h3>
				</section>
				
				<section>
				<h3>TODO? - Hibernate a JPA</h3>
				</section>
				
				<section>
				<h3>TODO? - Mapowanie JPA</h3>
				</section>
				
				<section>
				<h3>Encja a <b>POJO</b></h3>
				
									<pre><code class="Java" data-trim>
public class LibraryEntity {
	private String name;
	private String domain;

	public LibraryEntity () {
	}

	public String getName() { return name; }

	public void setName(String name) { this.name = name; }
	
	public String getDomain() { return domain; }

	public void setDomain(String domain) { this. domain = domain; }
}
					</code></pre>
				</section>
				
				<section>
				<h3><b>Encja</b> a POJO</h3>
				
									<pre><code class="Java" data-trim>
@Entity
public class LibraryEntity {

	@Id
	private Long id;
	
	@Column(name = "name", length = 30, nullable = false)
	private String name;
	
	@Column(name = "domain", length = 5, nullable = true)
	private String domain;
	
	public LibraryEntity () {
	}
	
	// getters and setters
}

					</code></pre>
				</section>
				
				<section>
				<h4>Adnotacje dla Encji</h4>
				
									<pre><code class="Java" data-trim>
@Entity
@Table(name = "LIBRARY", schema = "public")
@Access(AccessType.FIELD)
public class LibraryEntity {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Long id;
	
	@Column(name = "name", length = 30, nullable = false)
	private String name;
	
	@Lob
	@Column(nullable = false)
	private String description;
	
	private String city;
	
	@Access(AccessType.PROPERTY)
	public String getCity ()  { ... }
	
	public LibraryEntity ()  { }
	
}
					</code></pre>
				</section>
				
				<section>
				<h4>Adnotacje dla Encji</h4>
					<ul>
						<li><b>@Entity</b> - oznacza klasę, odzwierciedla tabelę BD
						<li><b>@Entity(name="…")</b> - nigdy nie używać
						<li><b>@Access</b> - decyduje gdzie umieszczać adnotacje
						<li><b>@Table</b> - zmienia domyślną nazwę tabeli BD
						<li><b>@Id</b> - oznacza atrybut jako klucz główny
						<li><b>@GeneratedValue</b> - auto generacja wartości PK
						<li><b>@Column</b> - pozwala ustawić wartości kolumny
						<li><b>@Lob</b> - typ dla dużych danych tekstowych
						<li><b>@Enumerated(EnumType.STRING)</b> - enumy
						<li><b>@Transient</b> - wyłączenie pola z persystencji
						<li><b>@MappedSuperclas</b> - zwykłe dziedziczenie
					</ul>
				</section>
				
				<section>
				<h4>Typy Embedded</h4>
					<pre><code class="Java" data-trim>
@Embeddable
public class PersonalData  {

 private String firstName;
 
 private String lastName;
 
 @Column (columnDefinition=" DATE", nullable = false)
 private Date birthDate;

 public PersonalData()  {
 }
 
 // getters & setters     
 
}
					</code></pre>
				</section>
				
				<section>
				<h4>Typy Embedded</h4>
					<pre><code class="Java" data-trim>
@Entity
public class AuthorEntity  {

  @Embedded
  @AttributeOverrides({
       @AttributeOverride(
           name = "firstName", 
           column = @Column(
              name = "FIRST_NAME", 
              nullable = false)),
       @AttributeOverride(
           name = "lastName",
           column = @Column(
       	      name = "LAST_NAME", 
       	      nullable = false))})
  vate PersonalData personalData;
  
  ...
}
					</code></pre>
				</section>
				
				<section>
				<h3>Generowanie kluczy głównych - Strategie</h3>
					<pre><code class="Java" data-trim>
					
   @Id
   @GeneratedValue(strategy = GenerationType.AUTO)
   private Long id;
					</code></pre>
					<pre><code class="Java" data-trim>
					
   @Id
   @SequenceGenerator(name = "bookGen", sequenceName = "BOOK_SEQ")
   @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "bookGen")
   private Long id;
					</code></pre>
				</section>
				
				<section>
				<h3>Generowanie kluczy głównych - Strategie</h3>
					<pre><code class="Java" data-trim>
					
    @Id
    @TableGenerator(
         name="bookGen",
         table="ID_GEN", // opcjonalnie
         pkColumnName="GEN_KEY", // opcjonalnie
         valueColumnName="GEN_VALUE", // opcjonalnie
         pkColumnValue="BOOK_ID_GEN") // opcjonalnie
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "bookGen")
    private Long id;
					</code></pre>
				</section>
				
				<section>
				<h3>Cykl życia encji</h3>
					<ul>
						<li>Adnotacje jako metadane opisujące mapowanie pomiędzy obiektem a bazą
						<li>Cykle życia encji:
						<ul>
							<li><b>nowy</b> (new) - brak identyfikatora i powiązania z kontekstem persystencji
							<li><b>zarządzany</b> (managed) – encja posiada ID i jest powiązana z kontekstem persystencji
							<li><b>odłączony</b> (detached) – encja posiada ID ale nie jest powiązana z kontekstem persystencji
							<li><b>usunięty</b> (removed) – tak jak zarządzany, ale oznaczona jako „do usunięcia”
						</ul>
					</ul>
				</section>
				
				<section>
				<h3>Listenery</h3>
					<ul>
						<li><b>@PrePersist</b>
						<li><b>@PostPersist    </b>
						<li><b>@PreUpdate      </b>
						<li><b>@PostUpdate     </b>
						<li><b>@PostLoad       </b>
						<li><b>@PreRemove      </b>
						<li><b>@PostRemove     </b>
					</ul>
				</section>
				
				<section>
				<h3>Listenery wewnątrz encji</h3>
					<pre><code class="Java" data-trim>
@Entity
@Table(name = "CUSTOMER_CARD")
public class CustomerCardEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
	
    @Column(nullable = false)
    private String serialNumber;

    @PrePersist
    public void generateDefaultSerialNumber() {
        serialNumber = new SerialNumberGenerator().generate();
    }
}
					</code></pre>
				</section>
				
				<section>
				<h3>Listenery stand alone</h3>
					<pre><code class="Java" data-trim>
@Entity
@Table(name = "CUSTOMER_CARD")
@EntityListeners(CustomerCardListener.class)
public class CustomerCardEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
	
    @Column(nullable = false)
    private String serialNumber;

}
					</code></pre>
				</section>
				
				<section>
				<h3>Listenery stand alone</h3>
					<pre><code class="Java" data-trim>
public class CustomerCardListener  {

    @PrePersist
    public void generateDefaultSerialNumber
			(CustomerCardEntity customerCardEntity) {
        String serialNumber = new SerialNumberGenerator().generate();
        customerCardEntity.setSerialNumber(serialNumber);
    }
	
}
					</code></pre>
				</section>
				
				<section>
				<h4>Entity Manager</h4>
					<ul>
						<li>Podstawowy element całej warstwy persystencji
						<li>Zarządza transakcjami i encjami
					</ul>
				
				
									<pre><code class="Java" data-trim>
String unitName = "MyPersistenceUnit";

// utwórz
EntityManagerFactory emf = Persistence.createEntityManagerFactory(unitName);
EntityManager em = emf.createEntityManager();

// zrób co masz do zrobienia
zrobCos(em);

// zamknij
em.close();
emf.close();
					</code></pre>
				</section>
				
				<section>
				<h4>Entity Manager - dostęp do danych</h4>
					<ul>
						<li>Podstawowy element całej warstwy persystencji
						<li>Zarządza transakcjami i encjami
					</ul>
				
				
									<pre><code class="Java" data-trim>
// zapis
Product banan = new Product(1, "banan", "owoce");
em.persist(banan);

// odczyt
Product bananFromDB = em.find(Product.class, 1);

// usunięcie
Product bananFromDB = em.find(Product.class, 1);
em.remove(bananFromDB);

// zapytanie
Product product = em.createQuery(
"SELECT p FROM Product p WHERE p.category = :cat_param", Product.class)
	.setParameter("cat_param", "owoce")
	.getSingleResult();

					</code></pre>
				</section>
				
				<section>
				<h3>TODO? - Relacje?</h3>
				</section>
				
				<section>
				<h3>TODO? - one to one?</h3>
				</section>
				
				<section>
				<h3>TODO? - One to many</h3>
				</section>
				
				<section>
				<h3>TODO? - Many to one</h3>
				</section>
				
				<section>
				<h3>TODO? - Many to many</h3>
				</section>
				
				<section>
				<h3>TODO? - Kaskady</h3>
				</section>
				
				<section>
				<h3>TODO? - Dziedziczenie</h3>
				</section>
				
				<section>
				<h3>TODO? - Strategie: Single Table</h3>
				</section>
				
				<section>
				<h3>TODO? - Strategie: Single Table2</h3>
				</section>
				
				<section>
				<h3>TODO? - Strategie: Single Table3</h3>
				</section>
				
				<section>
				<h3>TODO? - Strategie: Single Table4</h3>
				</section>
				
				<section>
				<h3>TODO? - Strategie: Single Table DB</h3>
				</section>
				
				<section>
				<h3>TODO? - Strategie: Table per class</h3>
				</section>
				
				<section>
				<h3>TODO? - Strategie: Joined</h3>
				</section>
				
				<section>
				<h3>TODO? - Strategie: Joined1</h3>
				</section>
				
				<section>
				<h3>TODO? - Strategie: Joined2</h3>
				</section>
				
				<section>
				<h3>TODO? - Optimistic Locking</h3>
				</section>
				
				
				<!--     ZADANIE DO WYKONANIA BookEntity      -->				
				<section>
				<h3>TODO? - ZADANIE DO WYKONANIA - 5 tabel - uzupełnianie adnotacji (autor, ...)</h3>
				</section>
				
				
				<!--     DAO     -->
				
				<section>
				<h3>Oddzielenie logiki domeny od obsługi trwałości</h3>
				<h4>Zastosowanie wzorca Data Access Object (DAO)</h4>
				<img src="images/dao.PNG" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h4>Dao - interfejs</h4>
				
									<pre><code class="Java" data-trim>
public interface Dao&lt;T&gt; {

	void create(T entity);
	T get(Serializable id);
	T load(Serializable id);
	List&lt;T&gt; getAll();
	void update(T entity);
	void saveOrUpdate(T entity);
	void delete(T entity);
	void delete(Serializable id);
	void deleteAll();
	long count();
	boolean exists(Serializable id);

}
					</code></pre>
				</section>				
				
				<section>
				<h4>Dao - implementacja</h4>
				
									<pre><code class="Java" data-trim>
@Transactional(Transactional.txType.SUPPORTS)
public abstract class AbstractDao&lt;T&gt; implements Dao&lt;T&gt; {
   
   @Autowired
   private SessionFactory sessionFactory;
   private Class&lt;T&gt; domainClass;
   
   protected Session getSession() { 
      return sessionFactory.getCurrentSession();
   }
   
   @Override
   public void create(T entity) {
      getSession().save(entity);
   }
   
   @Override
   @SuppressWarnings("unchecked")
   public T get(Serializable id) {
      return (T) getSession().get(getDomainClass(), id);
   }
   
   @Override
   public List&lt;T&gt; getAll() {
      return getSession().createQuery("from " + getDomainClassName()).list();
   }
}
					</code></pre>
				</section>		
				
				<section>
				<h4>Dao - implementacja</h4>
				
									<pre><code class="Java" data-trim>
@Repository
public class LibraryDaoImpl extends AbstractDao&lt;LibraryEntity&gt; {
   
   @SuppressWarnings("unchecked")
   public List&lt;LibraryEntity&gt; findByName(String name) {
      return getSession()
         .createQuery("from LibraryEntity l where l.name like :name")
         .setString("name", name + "%")
         .list();
   }
}
					</code></pre>
				</section>	
				
				<section>
				<h4>Obiekty DAO</h4>
					<ul>
						<li>Stanowią interfejs do komunikacji aplikacji z bazą danych
						<li>Nie zawierają logiki biznesowej
						<li>Oddzielają logikę biznesową od dostępu do danych
						<li>Powodują powstanie kolejnej warsty w aplikacji
					</ul>
				</section>
				
				
				
				<!--     ZADANIE DO WYKONANIA BookDao      -->	
				<section>
				<h3>TODO? - ZADANIE DO WYKONANIA book search criteria</h3>
				</section>
				
				
				<!--     Transakcje     -->
				
				<section>
				<h3>Transakcje</h3>
					<ul>
						<li>Zbiór operacji na bazie danych stanowiących jedną całość
 						<li>Zmieniają spójny stan bazy danych w inny spójny stan
 						<li>Cechy transakcji:
						<ul>
							<li>Atomowość (<b>A</b>tomicity)
							<li>Spójność (<b>C</b>onsistency)
							<li>Izolacja (<b>I</b>soation)
							<li>Trwałość (<b>D</b>urability)	
						</ul>
					</ul>
				</section>
				
				<section>
				<h4>Transakcje - Entity Manager</h4>
				
									<pre><code class="Java" data-trim>
// rozpoczyna transakcję
em.getTransaction().begin();

// wykonanie operacji
Product prodFromDb = em.find(Product.class, 1);
prodFromDb.setCategory("newCategory");

// zatwierdzenie transakcji
em.getTransaction().commit();

// ewentualne wycofanie transakcji
em.getTransaction().rollback();
					</code></pre>
				</section>
				
				<section>
				Transakcje Spring <b>@Transactional</b>
				
					<ul>
						<li>Najlepszy sposób budowania transakcyjnych aplikacji Spring 
 						<li>Brak powielonego kodu
						<li>Bardzo łatwa konfiguracja
						<li>Propagacja, izolacja, timeout, readOnly, rollbackFor itp.
						<li>Możliwość zdefiniowania na całej klasie i metodzie
					</ul>
				</section>	

				<section>
				<h4>@Transactional</h4>
				
									<pre><code class="Java" data-trim>
@Service
@Transactional(readOnly = true)
public class LibraryServiceImpl implements LibraryService {

	@Autowired
	private LibraryRepository libraryRepository;
	
	@Autowired
	private MapperFacade mapper;
	
	@Override
	public List&lt;LibraryTO&gt; findAllLibraries () {
		List&lt;LibraryEntity&gt; libraries = libraryRepository.findAll();
		return mapper.mapAsList(libraries, LibraryTO.class);
	}
}
					</code></pre>
				</section>				
				
								
				<section>
				<h3>TODO? - Przyklad z XMLem?</h3>
				</section>
				
				
				<!--     ZADANIE DO WYKONANIA BookService      -->
				<section>
				<h3>TODO? - Zadanie do wykonania - mapper, transakcje, zapis w bazie?</h3>
				</section>
				
				
				<!--     Testy     -->
				<section>
				<h3>TODO? - Testy</h3>
				</section>
				
				
				<!--     ZADANIE DO WYKONANIA Mockito      -->
								
				<section>
				<h3>TODO? - ZADANIE DO WYKONANIA, MOCKMVC, </h3>
				</section>
				
				
				
				
				

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', 

				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
